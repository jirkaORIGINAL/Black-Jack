<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoundrel (Responsive)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Roboto:wght@400;700&display=swap');

        :root {
            --color-bg: #1a1a1a;
            --color-surface: #2c3e50;
            --color-text: #ecf0f1;
            --color-accent: #f1c40f;
            --color-hearts: #c0392b;
            --color-diamonds: #a12a2a;
            --color-clubs: #27ae60;
            --color-spades: #34495e;
            --font-main: 'Roboto', sans-serif;
            --font-fancy: 'Cinzel', serif;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--color-bg);
            background-image: url('data:image/svg+xml,%3Csvg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="none" fill-rule="evenodd"%3E%3Cg fill="%23222" fill-opacity="0.4"%3E%3Cpath d="M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z"/%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
            color: var(--color-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px 0;
            box-sizing: border-box;
            user-select: none;
        }

        .game-container {
            max-width: 650px;
            width: 95%;
            padding: 30px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #000;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        #game-over-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; border-radius: 15px; z-index: 100; padding: 20px;
            cursor: pointer; /* Indicates it's clickable */
        }
        #game-over-message { font-size: 2em; font-family: var(--font-fancy); line-height: 1.5; color: var(--color-text); }
        #game-over-message span { color: var(--color-accent); font-size: 1.5em; display: block; margin: 10px 0; }
        #game-over-message small { font-size: 0.7em; font-family: var(--font-main); color: #ccc; display: block; margin-top: 20px; }

        .info-bar { display: flex; justify-content: space-between; width: 100%; margin-bottom: 20px; font-family: var(--font-fancy); font-size: 1.5em; }
        .player-stats { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; gap: 20px; }
        .health-container { flex-grow: 1; }
        .health-bar-bg { background-color: #555; border-radius: 10px; padding: 3px; border: 1px solid #111; }
        .health-bar { height: 20px; width: 100%; background-color: var(--color-hearts); border-radius: 7px; transition: width 0.2s ease-out; }
        #health-text { margin-top: 5px; text-align: center; }
        .weapon-slot { display: flex; align-items: center; justify-content: center; width: 220px; height: 50px; border: 2px dashed #666; border-radius: 10px; background-color: rgba(0,0,0,0.2); font-size: 1.2em; text-align: center; flex-shrink: 0; }
        #weapon { font-weight: bold; }

        .game-board { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; width: 100%; }
        .card-slot { aspect-ratio: 2.5 / 3.5; height: auto; width: 100%; border-radius: 10px; position: relative; background-color: rgba(0, 0, 0, 0.3); border: 2px dashed #444; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .card-slot:hover .card { border-color: var(--color-accent); transform: translateY(-5px); }
        .card-slot .key-hint { font-family: var(--font-fancy); color: #666; font-size: 2em; }

        .card { width: 100%; height: 100%; border-radius: 10px; cursor: pointer; position: absolute; display: flex; flex-direction: column; justify-content: space-between; font-weight: bold; box-sizing: border-box; border: 2px solid #111; box-shadow: 0 4px 8px rgba(0,0,0,0.3); transition: transform 0.1s ease-out, border-color 0.1s ease-out; }
        .card.HEARTS   { background: var(--color-hearts); }
        .card.DIAMONDS { background: var(--color-diamonds); }
        .card.SPADES   { background: var(--color-spades); }
        .card.CLUBS    { background: var(--color-clubs); }
        
        .card-value-top, .card-value-bottom { padding: 5px 10px; font-size: 1.5em; }
        .card-value-bottom { align-self: flex-end; transform: rotate(180deg); }
        .card-suit { font-size: 3.5em; text-align: center; }

        .controls-info { width: 100%; display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; color: #aaa; }
        .turn-status.active { color: var(--color-accent); font-weight: bold; }
        
        .control-btn {
            background-color: var(--color-surface);
            border: 1px solid #111;
            color: var(--color-text);
            padding: 8px 15px;
            border-radius: 8px;
            font-family: var(--font-main);
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .control-btn:hover { background-color: #3e5670; }
        .control-btn:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        @media (max-width: 600px) {
            .game-container { padding: 15px; }
            .info-bar { font-size: 1.2em; }
            .player-stats { flex-direction: column; align-items: stretch; gap: 15px; }
            .weapon-slot { width: 100%; }
            .game-board { gap: 10px; }
            .card-slot .key-hint { font-size: 1.5em; }
            .card-value-top, .card-value-bottom { font-size: 1em; padding: 4px 7px; }
            .card-suit { font-size: 2em; }
            .controls-info { font-size: 0.9em; }
            #game-over-message { font-size: 1.5em; }
            .control-btn { padding: 10px; }
        }

    </style>
</head>
<body>

<div class="game-container">
    <div id="game-over-overlay">
        <div id="game-over-message"></div>
    </div>

    <div class="info-bar">
        <div>Deck: <span id="deck-count">0</span></div>
        <div>Time: <span id="timer">0.0</span>s</div>
    </div>

    <div class="player-stats">
        <div class="health-container">
            <div class="health-bar-bg"><div id="health-bar" class="health-bar"></div></div>
            <div id="health-text">20 / 20</div>
        </div>
        <div class="weapon-slot">üó°Ô∏è <span id="weapon">None</span></div>
    </div>

    <div class="game-board" id="game-board">
        <div class="card-slot" id="slot-0"><span class="key-hint">Q</span></div>
        <div class="card-slot" id="slot-1"><span class="key-hint">W</span></div>
        <div class="card-slot" id="slot-2"><span class="key-hint">E</span></div>
        <div class="card-slot" id="slot-3"><span class="key-hint">R</span></div>
    </div>
    
    <div class="controls-info">
        <button class="control-btn" id="avoid-btn">[F] Avoid</button>
        <div id="turn-status"></div>
        <button class="control-btn" id="restart-btn">[T] Restart</button>
    </div>
</div>

<script>
    const suits = ['HEARTS', 'DIAMONDS', 'CLUBS', 'SPADES'];
    const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    
    let deck, room, health, maxHealth = 20;
    let weapon, lastMonsterValue;
    let potionUsedThisTurn, avoidedLastRoom, cardsPlayedThisTurn;
    let lastActionInfo;
    let timerInterval, gameStarted, gameIsOver;

    const dom = {
        deckCount: document.getElementById('deck-count'),
        timer: document.getElementById('timer'),
        healthBar: document.getElementById('health-bar'),
        healthText: document.getElementById('health-text'),
        weapon: document.getElementById('weapon'),
        turnStatus: document.getElementById('turn-status'),
        cardSlots: [document.getElementById('slot-0'), document.getElementById('slot-1'), document.getElementById('slot-2'), document.getElementById('slot-3')],
        gameOverOverlay: document.getElementById('game-over-overlay'),
        gameOverMessage: document.getElementById('game-over-message'),
        avoidBtn: document.getElementById('avoid-btn'),
        restartBtn: document.getElementById('restart-btn'),
    };

    function createDeck() {
        deck = [];
        for (const suit of suits) {
            for (const value of values) {
                if (!((suit === 'HEARTS' || suit === 'DIAMONDS') && ['K', 'Q', 'J', 'A'].includes(value))) {
                    deck.push({ suit, value });
                }
            }
        }
    }

    function shuffleDeck() {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }
    
    function startNewTurn() {
        cardsPlayedThisTurn = 0;
        potionUsedThisTurn = false;
        const cardsNeeded = 4 - room.filter(c => c).length;
        for (let i = 0; i < cardsNeeded; i++) {
            if (deck.length > 0) {
                const emptySlot = room.findIndex(s => s === null);
                if (emptySlot !== -1) room[emptySlot] = deck.pop();
            }
        }
        renderRoom();
        updateStats();
    }

    function renderRoom() {
        room.forEach((card, index) => {
            const slot = dom.cardSlots[index];
            slot.innerHTML = `<span class="key-hint">${['Q','W','E','R'][index]}</span>`;
            if (card) {
                const suitSymbol = getSuitSymbol(card.suit);
                const cardElement = document.createElement('div');
                cardElement.classList.add('card', card.suit);
                cardElement.innerHTML = `
                    <div class="card-value-top">${card.value}${suitSymbol}</div>
                    <div class="card-suit">${suitSymbol}</div>
                    <div class="card-value-bottom">${card.value}${suitSymbol}</div>`;
                cardElement.addEventListener('click', () => playCard(index));
                slot.appendChild(cardElement);
            }
        });
    }

    function getSuitSymbol(suit) { return {'HEARTS':'‚ô•', 'DIAMONDS':'‚ô¶', 'CLUBS':'‚ô£', 'SPADES':'‚ô†'}[suit]; }
    function getCardValue(card) {
        if (!isNaN(card.value)) return parseInt(card.value);
        return {'J': 11, 'Q': 12, 'K': 13, 'A': 14}[card.value];
    }

    function playCard(index) {
        if (gameIsOver || !gameStarted && !startGame()) return;
        if (index < 0 || index >= room.length || !room[index]) return;

        lastActionInfo = { wasMaxHealthPotion: false, value: 0 };
        const selectedCard = room[index];
        room[index] = null;
        cardsPlayedThisTurn++;

        if (selectedCard.suit === 'CLUBS' || selectedCard.suit === 'SPADES') {
            const monsterValue = getCardValue(selectedCard);
            let damage = monsterValue;
            if (weapon && monsterValue < lastMonsterValue) {
                damage = Math.max(0, monsterValue - getCardValue(weapon));
                lastMonsterValue = monsterValue;
            }
            health -= damage;
        } else if (selectedCard.suit === 'DIAMONDS') {
            weapon = selectedCard;
            lastMonsterValue = Infinity;
        } else if (selectedCard.suit === 'HEARTS') {
            if (!potionUsedThisTurn) {
                const potionValue = getCardValue(selectedCard);
                if (health === maxHealth) lastActionInfo = { wasMaxHealthPotion: true, value: potionValue };
                health = Math.min(maxHealth, health + potionValue);
                potionUsedThisTurn = true;
            }
        }

        renderRoom();
        updateStats();

        if (health <= 0) {
            endGame('lose');
            return;
        }
        
        if (cardsPlayedThisTurn === 3) {
            avoidedLastRoom = false;
            setTimeout(startNewTurn, 100);
        }
        
        if (deck.length === 0 && room.every(c => c === null)) {
            endGame('win');
        }
    }

    function avoidRoom() {
        if (gameIsOver || avoidedLastRoom || cardsPlayedThisTurn > 0) return;
        if (!gameStarted) startGame();
        const cardsInRoom = room.filter(c => c);
        deck.unshift(...cardsInRoom);
        room = [null, null, null, null];
        avoidedLastRoom = true;
        startNewTurn();
    }
    
    function updateStats() {
        dom.deckCount.textContent = deck.length;
        health = Math.max(0, health);
        dom.healthBar.style.width = `${(health / maxHealth) * 100}%`;
        dom.healthText.textContent = `${health} / ${maxHealth}`;
        
        if (weapon) {
            const weaponText = `${weapon.value}${getSuitSymbol(weapon.suit)}`;
            const detailText = (lastMonsterValue === Infinity) ? ` (Vs Any)` : ` (Vs &lt; ${lastMonsterValue})`;
            dom.weapon.innerHTML = `${weaponText}<span style="font-size: 0.8em; color: #ccc; margin-left: 5px;">${detailText}</span>`;
        } else {
            dom.weapon.textContent = 'None';
        }
        
        const canAvoid = !avoidedLastRoom && cardsPlayedThisTurn === 0;
        dom.avoidBtn.disabled = !canAvoid;
        
        dom.turnStatus.textContent = potionUsedThisTurn ? 'Potion Used' : '';
        dom.turnStatus.classList.toggle('active', potionUsedThisTurn);
    }

    function startGame() {
        if(gameStarted) return false;
        gameStarted = true;
        let startTime = Date.now();
        timerInterval = setInterval(() => {
            if (!gameIsOver) dom.timer.textContent = ((Date.now() - startTime) / 1000).toFixed(1);
        }, 100);
        return true;
    }
    
    function endGame(reason) {
        gameIsOver = true;
        let finalScore = 0;
        let messageTitle = "";

        if (reason === 'lose') {
            messageTitle = "You Have Been Defeated!";
            finalScore = health;
            const remainingMonsters = deck.concat(room.filter(c => c))
                                        .filter(c => c && (c.suit === 'CLUBS' || c.suit === 'SPADES'));
            for (const monster of remainingMonsters) {
                finalScore -= getCardValue(monster);
            }
        } else if (reason === 'win') {
            messageTitle = "You Cleared the Dungeon!";
            finalScore = health;
            if (lastActionInfo.wasMaxHealthPotion) {
                finalScore += lastActionInfo.value;
            }
        }
        
        const message = `${messageTitle}<br>Final Score: <span>${finalScore}</span><small>Tap Screen or Press [T] to Restart</small>`;
        dom.gameOverMessage.innerHTML = message;
        dom.gameOverOverlay.style.display = 'flex';
    }
    
    function restartGame() {
        clearInterval(timerInterval);
        
        deck = []; room = [null, null, null, null];
        health = 20; weapon = null; lastMonsterValue = Infinity;
        potionUsedThisTurn = false; avoidedLastRoom = false; cardsPlayedThisTurn = 0;
        lastActionInfo = { wasMaxHealthPotion: false, value: 0 };
        gameStarted = false; gameIsOver = false;

        dom.timer.textContent = "0.0";
        dom.gameOverOverlay.style.display = 'none';

        createDeck();
        shuffleDeck();
        startNewTurn();
    }

    function handleKeyPress(e) {
        const key = e.key.toUpperCase();
        if (key === 'T') {
            restartGame();
            return;
        }
        
        if (gameIsOver) return;

        if      (key === 'Q') playCard(0);
        else if (key === 'W') playCard(1);
        else if (key === 'E') playCard(2);
        else if (key === 'R') playCard(3);
        else if (key === 'F') avoidRoom();
    }

    // Attach all event listeners
    document.addEventListener('keydown', handleKeyPress);
    dom.avoidBtn.addEventListener('click', avoidRoom);
    dom.restartBtn.addEventListener('click', restartGame);
    dom.gameOverOverlay.addEventListener('click', restartGame); // Make the overlay clickable
    
    // Initial setup
    restartGame();

</script>

</body>
</html>
